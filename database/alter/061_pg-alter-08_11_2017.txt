set schema 'zafira';

/*
Function creates new table partition using current timestamp
as partition name identifier
*/

CREATE OR REPLACE FUNCTION CREATE_PARTITION(TABLE_NAME TEXT, MAX_COUNT_IN_PARTITION INTEGER, ITEM_ID INTEGER)
RETURNS TEXT AS
$$
DECLARE PARTITION_TABLE_NAME TEXT;
DECLARE PERIOD TEXT;
DECLARE LAST_ITEM_ID INTEGER;
BEGIN
    PERIOD := (SELECT CAST(EXTRACT(epoch FROM CURRENT_TIMESTAMP) AS INTEGER));
    PARTITION_TABLE_NAME := (TABLE_NAME || '_' || PERIOD);
    LAST_ITEM_ID :=(ITEM_ID + MAX_COUNT_IN_PARTITION);
    EXECUTE 'CREATE TABLE ZAFIRA.'|| PARTITION_TABLE_NAME ||' (LIKE ZAFIRA.'||TABLE_NAME||' INCLUDING ALL)';
    EXECUTE 'ALTER TABLE ZAFIRA.'|| PARTITION_TABLE_NAME ||' ADD CONSTRAINT '|| PARTITION_TABLE_NAME ||'_CREATED_AT_CHECK
             CHECK (ID >= '||ITEM_ID||' AND ID < '||LAST_ITEM_ID||');';
    EXECUTE 'ALTER TABLE ZAFIRA.'|| PARTITION_TABLE_NAME ||' INHERIT ZAFIRA.'||TABLE_NAME||';';
 RETURN PARTITION_TABLE_NAME;
END
$$
LANGUAGE plpgsql;

/*
Function inserts each new row of the table
into the table partition for which function was created.
*/

CREATE OR REPLACE FUNCTION CREATE_INSERT_FUNCTION(INSERT_FUNCTION_NAME TEXT, TABLE_NAME TEXT, PARTITION_TABLE_NAME TEXT)
RETURNS VOID AS
$$
BEGIN
    EXECUTE
    'CREATE OR REPLACE FUNCTION ' || INSERT_FUNCTION_NAME ||'
    RETURNS TRIGGER AS
    $BODY$
    DECLARE r ZAFIRA.' || TABLE_NAME || '%rowtype;
    BEGIN
    INSERT INTO ZAFIRA.'|| PARTITION_TABLE_NAME ||' VALUES (NEW.*) RETURNING * INTO r;
    RETURN r;
    END
    $BODY$
    LANGUAGE plpgsql;';
END
$$
LANGUAGE plpgsql;

/*
Function creates trigger on the table
which invokes insert function every time when
item count in partition <> MAX_COUNT
*/

CREATE OR REPLACE FUNCTION CREATE_INSERT_TRIGGER(INSERT_FUNCTION_NAME TEXT, TABLE_NAME TEXT, INSERT_TRIGGER_NAME TEXT, MAX_COUNT_IN_PARTITION INTEGER)
RETURNS VOID AS
$$
BEGIN
EXECUTE
'CREATE TRIGGER '|| INSERT_TRIGGER_NAME ||'
	BEFORE INSERT ON ZAFIRA.'|| TABLE_NAME ||'
    FOR EACH ROW
    WHEN (NEW.id = 1 OR (NEW.id - 1) % '||MAX_COUNT_IN_PARTITION||' <> 0)
    EXECUTE PROCEDURE '|| INSERT_FUNCTION_NAME ||'';
END
$$
LANGUAGE plpgsql;

/*
Function creates new table partition, then creates
insert function which is connected with new partiton and
trigger which invokes insert function.
*/

CREATE OR REPLACE FUNCTION CREATE_INSERT_FUNCTION_AND_TRIGGER
(TABLE_NAME TEXT, INSERT_FUNCTION_NAME TEXT, INSERT_TRIGGER_NAME TEXT, MAX_COUNT_IN_PARTITION INTEGER, ITEM_ID INTEGER)
RETURNS TEXT AS
$$
DECLARE NEW_PARTITION_TABLE_NAME TEXT;
BEGIN
    SELECT ZAFIRA.CREATE_PARTITION(TABLE_NAME, MAX_COUNT_IN_PARTITION, ITEM_ID) INTO NEW_PARTITION_TABLE_NAME;
    PERFORM ZAFIRA.CREATE_INSERT_FUNCTION(INSERT_FUNCTION_NAME, TABLE_NAME, NEW_PARTITION_TABLE_NAME);
    PERFORM ZAFIRA.CREATE_INSERT_TRIGGER(INSERT_FUNCTION_NAME, TABLE_NAME, INSERT_TRIGGER_NAME, MAX_COUNT_IN_PARTITION);
    RETURN NEW_PARTITION_TABLE_NAME;
END
$$
LANGUAGE plpgsql;

/*
Function drops
function connecting the table with current partition, creates
new partition with insert function & trigger for it,
then inserts new row into the new partition.
*/

CREATE OR REPLACE FUNCTION CREATE_UPDATE_FUNCTION(UPDATE_FUNCTION_NAME TEXT, INSERT_FUNCTION_NAME TEXT, TABLE_NAME TEXT, INSERT_TRIGGER_NAME TEXT, MAX_COUNT_IN_PARTITION INTEGER)
RETURNS VOID AS
$$
BEGIN
EXECUTE
    'CREATE OR REPLACE FUNCTION '||UPDATE_FUNCTION_NAME||'
    RETURNS TRIGGER AS
    $BODY$
    DECLARE r ZAFIRA.'||TABLE_NAME||'%rowtype;
    DECLARE PARTITION_TABLE_NAME TEXT;
    BEGIN
    DROP FUNCTION IF EXISTS ZAFIRA.'||INSERT_FUNCTION_NAME||' CASCADE;
    SELECT ZAFIRA.CREATE_INSERT_FUNCTION_AND_TRIGGER('''||TABLE_NAME||''','''||INSERT_FUNCTION_NAME||''','''||INSERT_TRIGGER_NAME||''','||MAX_COUNT_IN_PARTITION||', NEW.id)
    INTO PARTITION_TABLE_NAME;
    EXECUTE ''INSERT INTO ZAFIRA.''|| PARTITION_TABLE_NAME ||'' VALUES ($1.*) RETURNING * '' INTO r USING NEW;
    RETURN r;
    END;
    $BODY$
    LANGUAGE plpgsql;';
END
$$
LANGUAGE plpgsql;

/*
Function creates trigger on the table which invokes
update function when
item count in partition reaches MAX_COUNT
(is called always after insert trigger in order to avoid
asynchronous calls)
*/

CREATE OR REPLACE FUNCTION CREATE_UPDATE_TRIGGER(UPDATE_FUNCTION_NAME TEXT, TABLE_NAME TEXT, UPDATE_TRIGGER_NAME TEXT, MAX_COUNT_IN_PARTITION INTEGER)
RETURNS VOID AS
$$
BEGIN
EXECUTE
'CREATE TRIGGER '|| UPDATE_TRIGGER_NAME ||'
	BEFORE INSERT ON ZAFIRA.'|| TABLE_NAME ||'
    FOR EACH ROW
    WHEN (NEW.id <> 1 AND (NEW.id - 1) % '||MAX_COUNT_IN_PARTITION||' = 0)
    EXECUTE PROCEDURE '|| UPDATE_FUNCTION_NAME ||'';
END
$$
LANGUAGE plpgsql;

/*
Function creates for the table
update function and trigger for update function.
*/

CREATE OR REPLACE FUNCTION CREATE_UPDATE_FUNCTION_AND_TRIGGER
(TABLE_NAME TEXT, INSERT_FUNCTION_NAME TEXT, INSERT_TRIGGER_NAME TEXT,
 UPDATE_FUNCTION_NAME TEXT, UPDATE_TRIGGER_NAME TEXT, MAX_COUNT_IN_PARTITION INTEGER)
RETURNS VOID AS
$$
BEGIN
PERFORM ZAFIRA.CREATE_UPDATE_FUNCTION(UPDATE_FUNCTION_NAME, INSERT_FUNCTION_NAME, TABLE_NAME, INSERT_TRIGGER_NAME, MAX_COUNT_IN_PARTITION);
PERFORM ZAFIRA.CREATE_UPDATE_TRIGGER(UPDATE_FUNCTION_NAME, TABLE_NAME, UPDATE_TRIGGER_NAME, MAX_COUNT_IN_PARTITION);
END
$$
LANGUAGE plpgsql;

/*
Function deletes row from master table after
inserting it into partition.
*/

CREATE OR REPLACE FUNCTION CREATE_DELETE_FUNCTION(DELETE_FUNCTION_NAME TEXT, TABLE_NAME TEXT)
RETURNS VOID AS
$$
BEGIN
EXECUTE
'CREATE OR REPLACE FUNCTION ' || DELETE_FUNCTION_NAME || '
     RETURNS TRIGGER AS
     $BODY$
     DECLARE r ZAFIRA.' || TABLE_NAME || '%rowtype;
     BEGIN
     DELETE FROM ONLY  ZAFIRA.'|| TABLE_NAME ||' where id = NEW.id returning * into r;
     RETURN r;
     END;
     $BODY$
     LANGUAGE plpgsql;';
END
$$
LANGUAGE plpgsql;

/*
Function creates trigger invoking delete function
*/

CREATE OR REPLACE FUNCTION CREATE_DELETE_TRIGGER(DELETE_FUNCTION_NAME TEXT, TABLE_NAME TEXT, DELETE_TRIGGER_NAME TEXT)
RETURNS VOID AS
$$
BEGIN
EXECUTE
'CREATE TRIGGER ' || DELETE_TRIGGER_NAME ||'
     AFTER INSERT ON ' || TABLE_NAME ||'
     FOR EACH ROW
     EXECUTE PROCEDURE ' || DELETE_FUNCTION_NAME ||'';
END
$$
LANGUAGE plpgsql;

/*
Function creates for the table delete function and
trigger invoking delete function
*/

CREATE OR REPLACE FUNCTION CREATE_DELETE_FUNCTION_AND_TRIGGER(TABLE_NAME TEXT, DELETE_FUNCTION_NAME TEXT, DELETE_TRIGGER_NAME TEXT)
RETURNS VOID AS
$$
BEGIN
PERFORM ZAFIRA.CREATE_DELETE_FUNCTION(DELETE_FUNCTION_NAME, TABLE_NAME);
PERFORM ZAFIRA.CREATE_DELETE_TRIGGER(DELETE_FUNCTION_NAME, TABLE_NAME, DELETE_TRIGGER_NAME);
END
$$
LANGUAGE plpgsql;

/*
Method is called directly for every table which requires partitioning.
Takes TABLE_NAME text as parameter and generates
trigger infrastructure for chosen table which
provides partitioning of the table.
*/

CREATE OR REPLACE FUNCTION GENERATE_PARTITION(TABLE_NAME TEXT)
RETURNS VOID AS
$$
DECLARE INSERT_FUNCTION_NAME TEXT;
DECLARE UPDATE_FUNCTION_NAME TEXT;
DECLARE DELETE_FUNCTION_NAME TEXT;
DECLARE INSERT_TRIGGER_NAME TEXT;
DECLARE UPDATE_TRIGGER_NAME TEXT;
DECLARE DELETE_TRIGGER_NAME TEXT;
DECLARE MAX_COUNT_IN_PARTITION INTEGER;

BEGIN
/* FUNCTION for inserting NEW rows in PARTITION */
INSERT_FUNCTION_NAME := (TABLE_NAME || '_insert_row_in_PARTITION()');

/* FUNCTION for creating NEW PARTITION if necessary and
inserting NEW row in the PARTITION */
UPDATE_FUNCTION_NAME := (TABLE_NAME || '_ADD_PARTITION()');

/* FUNCTION for deleting raw from master table
after it has been inserted into PARTITION */
DELETE_FUNCTION_NAME := (TABLE_NAME || '_DELETE_row_from_master()');

/* TRIGGER calling insert FUNCTION*/
INSERT_TRIGGER_NAME := (TABLE_NAME || '_INSERT_TRIGGER');

/* TRIGGER calling update FUNCTION*/
UPDATE_TRIGGER_NAME := (TABLE_NAME || '_UPDATE_TRIGGER');

/* TRIGGER calling delete FUNCTION*/
DELETE_TRIGGER_NAME := (TABLE_NAME || '_DELETE_TRIGGER');

/* TODO Requires reasonable MAX_COUNT_IN_PARTITION replacement
according to table potential size */

IF LOWER(TABLE_NAME) = 'test_runs' THEN
    MAX_COUNT_IN_PARTITION := 3;
ELSIF LOWER(TABLE_NAME) = 'tests' THEN
    MAX_COUNT_IN_PARTITION := 16;
    ALTER TABLE zafira.tests DROP CONSTRAINT IF EXISTS fk_tests_test_runs1;
ELSIF LOWER(TABLE_NAME) = 'test_work_items' THEN
    MAX_COUNT_IN_PARTITION := 35;
    ALTER TABLE zafira.test_work_items DROP CONSTRAINT IF EXISTS fk_test_work_items_tests1;
ELSIF LOWER(TABLE_NAME) = 'test_artifacts' THEN
    MAX_COUNT_IN_PARTITION := 40;
    ALTER TABLE zafira.test_artifacts DROP CONSTRAINT  IF EXISTS fk_test_artifacts_tests1;
ELSE
    RAISE EXCEPTION 'UNDEFINED TABLE_NAME!';
END IF;

EXECUTE 'DROP TRIGGER IF EXISTS '||INSERT_TRIGGER_NAME||' ON '||TABLE_NAME||';';
EXECUTE 'DROP TRIGGER IF EXISTS '||DELETE_TRIGGER_NAME||' ON '||TABLE_NAME||';';
EXECUTE 'DROP TRIGGER IF EXISTS '||UPDATE_TRIGGER_NAME||' ON '||TABLE_NAME||';';

PERFORM ZAFIRA.CREATE_INSERT_FUNCTION_AND_TRIGGER
(TABLE_NAME, INSERT_FUNCTION_NAME, INSERT_TRIGGER_NAME, MAX_COUNT_IN_PARTITION, 1);

PERFORM ZAFIRA.CREATE_UPDATE_FUNCTION_AND_TRIGGER
(TABLE_NAME, INSERT_FUNCTION_NAME, INSERT_TRIGGER_NAME,
 UPDATE_FUNCTION_NAME, UPDATE_TRIGGER_NAME, MAX_COUNT_IN_PARTITION);

PERFORM ZAFIRA.CREATE_DELETE_FUNCTION_AND_TRIGGER
(TABLE_NAME, DELETE_FUNCTION_NAME, DELETE_TRIGGER_NAME);

END $$
LANGUAGE plpgsql;

SELECT GENERATE_PARTITION('tests');



